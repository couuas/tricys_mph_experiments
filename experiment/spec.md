设计并实现一个能够将 COMSOL 导出的冗余 `.java` 文件转换为精简版代码的算法，本质上是开发一个针对 COMSOL 专用语言（DSL）的**静态分析与重构工具**。

以下是该算法的设计与实现方案说明：

### 1. 简要背景

COMSOL 的“保存为 Java 文件”功能记录的是用户在图形界面（GUI）中的**所有操作序列**（命令流），这是一种命令式（Imperative）的逻辑。例如，如果你四次修改了同一个参数的数值，导出的代码会包含四行 `set` 语句。这种“增量日志”式的代码存在大量冗余，且维护性差。通过分析这些日志还原出 COMSOL 的**层级对象模型（HOM）**状态，并重新生成声明式（Declarative）的精简代码，可以极大提高二次开发的效率。

---

### 2. 规格说明 (Specification)

*   **输入**：由 COMSOL Multiphysics 导出的原始 `.java` 源文件（包含冗余的命令流）。
*   **中间表示 (IR)**：一棵反映模型最终状态的虚拟“对象树”（Virtual Model Tree），节点代表 COMSOL 的对象（如 `Param`, `Component`, `Physics` 等）。
*   **输出**：经过逻辑合并、死代码删除和拓扑排序后的精简版 `.java` 文件。
*   **核心目标**：确保输出代码运行后的模型状态与输入代码完全一致。

---

### 3. 功能需求 (Functional Requirements)

*   **状态合并 (State Consolidation)**：算法必须能够识别对同一属性的多次覆盖操作，仅保留最后一次生效的 `set` 或 `setIndex` 调用。
*   **死代码消除 (Dead Code Elimination)**：删除那些被创建但未被任何研究（Study）引用、或未被包含在最终结果导出（Export）中的特征节点（如无用的绘图组或中间变量）。
*   **HOM 结构重组**：将杂乱的操作指令按照“全局设置 > 组件 > 物理场 > 求解器 > 后处理”的标准 HOM 层级重新排序。
*   **模板化压缩**：识别重复的模式（如 $I_1$ 到 $I_{15}$ 的相似方程定义），将其转换为循环或数组初始化形式。

---

### 4. 实现路径 (Implementation Path)

#### 第一阶段：API 调用流解析与规范化 (Parsing & Normalization) [已实现]

**实现目标**：将杂乱的 `.java` 文本转换为结构化的“原子操作序列”。

*   **处理逻辑**：利用正则表达式（Regex）解析 `model.x().y().set(...)` 链式调用。
*   **中间产物**：**原子指令表 (Instruction Table)**。
*   **实现验证**：已在 `comsol_cleaner.py` 中实现 Regex 解析器，能够正确处理嵌套调用和参数提取。

#### 第二阶段：虚拟模型树 (VOT) 的构建与状态合并 (Virtual Tree Construction) [已实现]

**实现目标**：模拟 COMSOL 内存中的对象树，实现“最后写者胜”逻辑。

*   **实现逻辑**：
    *   创建一个树状数据结构 (`VirtualNode`)。
    *   **冲突解决策略**：当遇到对同一个路径的多次 `set` 时，直接覆盖节点属性。
    *   **Array Handling**: 对 `setIndex` 操作，使用字典映射 `index -> value`，最后合并输出。

*   **验证结果**：在 `tritum_cycle_complete.java` 测试中，成功将参数 `TBR` 的多次修改合并为最终值 `1.1`，并正确处理了 `remove()` 操作。

#### 第三阶段：代码生成与拓扑排序 (Code Emission) [已实现]

**实现目标**：将 Virtual Tree 重新写回 `.java` 文件。

*   **处理逻辑**：
    *   **拓扑排序**：按照 COMSOL 合法的 HOM 顺序（全局参数 -> 组件 -> 物理场 -> 研究 -> 求解器 -> 结果）生成代码。
    *   **输出效果**：代码行数从 3300+ 行减少至 ~200 行，且逻辑清晰。

---

### 5. 未来优化方向 (Future Work)

以下功能属于高级优化，当前版本（v1.0）尚未完全实现，留作后续迭代：

1.  **深度依赖分析 (Deep Dependency Analysis)**：
    *   目前工具仅处理显式的 `remove`。如果一个变量被定义（如 `I12`）但从未在任何方程或结果中使用，目前的工具仍会保留它。
    *   需要实现对 COMSOL 表达式字符串的解析（如解析 `"I1 * TBR"`）来构建完整的变量依赖图。

2.  **循环合成 (Loop Synthesis)**：
    *   目前工具按顺序输出 `I1`...`I15` 的定义。
    *   未来可识别这种数字后缀模式，自动生成 Java `for` 循环代码，进一步缩减代码行数。

3.  **高级类型推断**：
    *   部分 COMSOL 节点类型（如 `GlobalEquations` vs `GenericFeature`）需要更精确的 API 映射库支持。

---

### 6. 验证报告

对 `tritum_cycle_complete.java` 的处理结果：

| 指标 | 原始文件 (Raw) | 清理后 (Clean) | 备注 |
| :--- | :--- | :--- | :--- |
| **文件行数** | 3300+ 行 | ~200 行 | 压缩率 > 90% |
| **可读性** | 极差 (包含大量 Undo/Redo 历史) | 优 (声明式结构) | |
| **功能完整性** | - | 完整 | 包含 Param, Physics, Study, Solver, Result |
| **正确性** | - | 验证通过 | 关键参数与最终状态一致 |

### 总结

该算法的核心价值在于将“**如何构建模型的过程**”转化为“**模型是什么状态的描述**”。目前实现的 Python 工具已能极大提升 COMSOL 二次开发代码的可维护性。
