针对氚循环模型（Tritium Cycle Model）的批量仿真需求，以下是基于 COMSOL Java API 实现的两种参数扫描方案的详细对比总结：

---

### 1. 方案一：Java 外部循环批量仿真 (`tritum_cycle_batch.java`)

该方案利用 Java 语言本身的 `for` 循环来控制仿真流程，每次循环被视为一个独立的任务。

* **实现机制**：
* 使用 Java 的 `for` 循环遍历参数数组（如 `tbrValues = {1.05, 1.10, 1.15, 1.20}`）。
* 每次迭代中调用 `model.param().set()` 修改具体参数（如 `TBR`）。
* 通过 `model.sol("sol1").runAll()` 触发独立求解，并使用 `ModelUtil.remove()` 在循环结束时释放内存。


* **数据管理**：
* 为每个参数值生成独立的结果文件（如 `SDS_TBR_1.05.png` 和 `Data_TBR_1.05.csv`）。


* **适用场景**：
* 需要为每个参数生成单独的模型文件（`.mph`）或独立的报告时。
* 仿真规模极大，需要通过循环频繁释放内存以防止程序崩溃时。



---

### 2. 方案二：内置参数化扫描 (`tritum_cycle_sweep.java`)

该方案利用 COMSOL 求解器内部的 `Parametric` 特征节点，将参数变化集成在研究（Study）层级中。

* **实现机制**：
* 在研究节点下创建扫描特征：`model.study("std1").feature().create("p1", "Parametric")`。
* 一次性定义所有参数点：`set("plistarr", new String[]{"1.05 1.10 1.15 1.20"})`。
* 求解器会自动优化计算序列，并将所有结果存储在一个多维数据集（通常为 `dset2`）中。


* **数据管理**：
* 所有参数的解都存在同一个模型文件中。
* 绘图时通过设置 `legendmethod` 为 `manual` 或 `evaluated`，可以在同一张图中显示多条对比曲线。


* **适用场景**：
* **灵敏度分析**：需要直观对比不同 `TBR` 或滞留时间  对 SDS 最终库存  的影响时。
* 需要将不同实验组的曲线放在一起进行学术绘图或对比时。



---

### 3. 核心差异对比表

| 特性维度 | 方案一：Java 外部循环 | 方案二：内置参数化扫描 |
| --- | --- | --- |
| **逻辑控制** | 由 Java 虚拟机（JVM）控制循环 | 由 COMSOL 求解器核心控制 |
| **结果展示** | 多个独立图片/文件，难以直接在一张图中对比 | 自动在同一张图中生成多条对比曲线 |
| **内存占用** | 优秀。可通过 `ModelUtil.remove()` 定期清理 | 一般。所有结果会累积在内存/数据集中 |
| **执行速度** | 每次需重新初始化求解器，速度稍慢 | 求解器内部优化，跳过重复初始化，速度较快 |
| **数据源引用** | 始终引用默认数据集 `dset1` | 必须显式引用扫描数据集 `dset2` |

---

### 4. 实验涉及的关键物理项

无论采用哪种方案，模型均严格遵循了文档定义的物理逻辑：

* 
**动态通量**：考虑了各系统的滞留时间 （如 ）和份额 （如 ） 。


* 
**库存控制**：在  (SDS) 的控制方程中，综合了燃烧消耗、补给速率及放射性衰变   。


* **饱和逻辑**：使用了 `if(Inventory > Saturation, ...)` 逻辑来模拟系统的排空与溢流行为。
